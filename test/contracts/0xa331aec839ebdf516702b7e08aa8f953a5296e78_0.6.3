/**
 *Submitted for verification at Etherscan.io on 2020-03-26
*/

pragma solidity 0.6.3; contract AENfileCertifier {  address private root; struct LedgerRecord {  uint _unixCertified;  bytes32 _sha256hash;  bytes16 _md5hash;  uint _filesize;  string _fileName;  string _issueDate;  string _title;  string _office;  address _owner;  }  LedgerRecord private buf;  mapping (bytes32 => LedgerRecord) private ledger;   event WriteRecord (address indexed from, bytes32 indexed sha256crc, string fileName, string issueDate, string title, string office); event EditRecord (address indexed from, bytes32 indexed sha256crc, string fileName, string issueDate, string title, string office); event OpenLedger (address indexed from); event WrongCall (address indexed from, bytes callsequence); function writeLedger(bytes32 sha256crc, bytes16 MD5crc, uint filesize, string memory fileName, string memory issueDate, string memory title, string memory office) public {  require(sha256crc != bytes32(0) && MD5crc != bytes32(0) && filesize != uint(0), "Error: missing data in the record." );  require(ledger[sha256crc]._unixCertified == uint (0x0), "Error: this record is already present!");  buf._unixCertified = block.timestamp; buf._fileName = fileName; buf._issueDate = issueDate; buf._title = title; buf._office = office; buf._sha256hash = sha256crc; buf._md5hash = MD5crc; buf._filesize = filesize; buf._owner = msg.sender;  ledger[sha256crc] = buf;  emit WriteRecord(msg.sender, sha256crc, fileName, issueDate, title, office); } function readLedger(bytes32 sha256crc) view public returns (uint unixCertified, string memory certifiedUTCdate, bytes16 MD5crc, uint filesize, string memory fileName, string memory issueDate, string memory title, string memory office) { if(ledger[sha256crc]._unixCertified == uint (0x0)){  string memory error = "Error: requested record does not exist."; unixCertified = 0; certifiedUTCdate= error; MD5crc = 0; filesize = 0; fileName = error; issueDate = error; title = error; office = error; } else { unixCertified = ledger[sha256crc]._unixCertified; certifiedUTCdate= string(abi.encodePacked(u2s(getDay(unixCertified)), "/", u2s(getMonth(unixCertified)), "/", u2s(getYear(unixCertified)), ", ", u2s(getHour(unixCertified)), ":", u2s(getMinute(unixCertified)), ":", u2s(getSecond(unixCertified)), " UTC")); MD5crc = ledger[sha256crc]._md5hash; filesize = ledger[sha256crc]._filesize; fileName = ledger[sha256crc]._fileName; issueDate = ledger[sha256crc]._issueDate; title = ledger[sha256crc]._title; office = ledger[sha256crc]._office; } } function checkOwner(bytes32 sha256crc) public view returns(address owner, string memory title, bool success) { if(ledger[sha256crc]._unixCertified == uint (0x0)){  owner = address(0x0); title = "Error: requested record does not exist."; success = false; } else { owner = ledger[sha256crc]._owner; title = ledger[sha256crc]._title; success = true; } } function editLedger(bytes32 sha256crc, string memory fileName, string memory issueDate, string memory title, string memory office) public { require(msg.sender == root, "Error: insufficient privileges.");  require(ledger[sha256crc]._unixCertified != uint (0x0), "Error: requested record does not exist!");  ledger[sha256crc]._fileName = fileName; ledger[sha256crc]._issueDate = issueDate; ledger[sha256crc]._title = title; ledger[sha256crc]._office = office;  emit EditRecord(msg.sender, sha256crc, fileName, issueDate, title, office); } constructor () public { root = msg.sender; emit OpenLedger(root); } receive() external payable { revert("Ethers are not accepted!");  } fallback() external { emit WrongCall (msg.sender, msg.data);  } struct _DateTime {uint16 year;uint8 month;uint8 day;uint8 hour;uint8 minute;uint8 second;uint8 weekday;} uint constant YEAR_IN_SECONDS=31536000;uint constant LEAP_YEAR_IN_SECONDS=31622400;uint constant DAY_IN_SECONDS=86400;uint16 constant ORIGIN_YEAR=1970; function getYear(uint timestamp)internal pure returns(uint16 year){uint secondsAccountedFor=0;uint numLeapYears;year=uint16(ORIGIN_YEAR+timestamp/YEAR_IN_SECONDS);numLeapYears=leapYearsBefore(year)-leapYearsBefore(ORIGIN_YEAR);secondsAccountedFor+=LEAP_YEAR_IN_SECONDS*numLeapYears;secondsAccountedFor+=YEAR_IN_SECONDS*(year-ORIGIN_YEAR-numLeapYears);while(secondsAccountedFor>timestamp){if(isLeapYear(uint16(year-1))){secondsAccountedFor-=LEAP_YEAR_IN_SECONDS;}else{secondsAccountedFor-=YEAR_IN_SECONDS;}year-= 1;}return year;} function getMonth(uint timestamp)internal pure returns(uint8){return parseTimestamp(timestamp).month;} function getDay(uint timestamp)internal pure returns (uint8){return parseTimestamp(timestamp).day;} function getHour(uint timestamp)internal pure returns(uint8){return uint8((timestamp/60/60)%24);} function getMinute(uint timestamp)internal pure returns(uint8){return uint8((timestamp/60)%60);} function getSecond(uint timestamp)internal pure returns(uint8){return uint8(timestamp%60);} function getWeekday(uint timestamp)internal pure returns(uint8){return uint8((timestamp/DAY_IN_SECONDS+4)%7);} function parseTimestamp(uint timestamp)internal pure returns(_DateTime memory dt){uint secondsAccountedFor=0;uint _buf;uint8 i;dt.year=getYear(timestamp);_buf=leapYearsBefore(dt.year)-leapYearsBefore(ORIGIN_YEAR);secondsAccountedFor+=LEAP_YEAR_IN_SECONDS*_buf;secondsAccountedFor+=YEAR_IN_SECONDS*(dt.year-ORIGIN_YEAR-_buf);uint secondsInMonth;for(i=1;i<=12;i++){secondsInMonth=DAY_IN_SECONDS*getDaysInMonth(i,dt.year);if(secondsInMonth+secondsAccountedFor>timestamp){dt.month=i;break;} secondsAccountedFor+=secondsInMonth;}for(i=1;i<=getDaysInMonth(dt.month,dt.year);i++){if(DAY_IN_SECONDS+secondsAccountedFor>timestamp){dt.day=i;break;}secondsAccountedFor+=DAY_IN_SECONDS;}dt.hour=getHour(timestamp);dt.minute=getMinute(timestamp);dt.second=getSecond(timestamp);dt.weekday=getWeekday(timestamp);} function isLeapYear(uint16 year)internal pure returns(bool){if(year%4!=0)return false;if(year%100!=0)return true;if(year%400!=0)return false;return true;} function leapYearsBefore(uint year)internal pure returns(uint){year-=1;return year/4-year/100+year/400;} function getDaysInMonth(uint8 month,uint16 year)internal pure returns(uint8){if(month==1||month==3||month==5||month==7||month==8||month==10||month==12){return 31;}else if(month==4||month==6||month==9||month==11){return 30;}else if(isLeapYear(year)){return 29;}else{return 28;}} function u2s(uint v)internal pure returns(string memory){bytes32 ret;uint vl=v;if(v==0){ret='0';}else{while(v>0){ret=bytes32(uint(ret)/(2**8));ret|=bytes32(((v%10)+48)*2**(8*31));v/=10;}}bytes memory bytesString=new bytes(32);for(uint j=0;j<32;j++){byte char=byte(bytes32(uint(ret)*2**(8*j)));if(char!=0){bytesString[j]=char;}}if(vl<10)bytesString=abi.encodePacked("0",bytesString);return string(bytesString);} }